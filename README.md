# trebizond

### Byzantine fault tolerant consensus algorithm for permissioned blockchain systems

Blockchain systems have been drawing a great deal of interest since their first appearance due to their use in cryptocurrencies, having Bitcoin as their pioneer and the most iconic of them. Their applications spread to any system which requires to keep a replicated log of documents or transactions, ensuring eventual consistency on the state shared among the replicas, data integrity and fault tolerance by means of a consensus algorithm.

Trebizond is a byzantine fault tolerant algorithm particularly suitable for its application in permissioned blockchain systems. It is influenced by Raft and PBFT. From the former it takes its design principles, which lay on problem separation, state space reduction, and the algorithm's own intelligibility. From the latter it takes some of the elements which enable the algorithm to be provided with fault tolerance in the byzantine setting.

After carrying out a detailed study about the problem of distributed consensus and other typical problems of distributed systems which are tightly bound to it, followed by a summary of the main permissioned blockchain networks currently in exploitation, Trebizond's functional specification is formulated. This algorithm tries to reach consensus in an eventually synchronous authenticated setting, where byzantine failures may arise. Regarding the current state of research in this area, Trebizond's main contribution is its combination of active failure detection and semantic validation. While other algorithms make use of active failure detection as a means of improving their fault tolerance degree in relation to the failure masking strategy commonly used, and other algorithms rely on semantic or external validation when it comes to appreciate whether an operation is legal to be executed on the shared state, Trebizond proposes to fuse both techniques. It aims to use semantic validation, this being dependent on the higher level protocol which executes on top of the consensus algorithm, as a part of the active failure detection system, thus improving its effectiveness and completeness. This polished failure detector makes possible to perform actions such as deposing a leader when it is detected for having been sending messages which are coherent with the consensus algorithm itself but violate the application level protocol, or isolating a replica from the communication group when evidences exist that it has featured byzantine behavior.

The algorithm's safety and liveness properties are first outlined and subsequently highlighted by means of input/output automatons, a well-known technique for crafting distributed algorithms. Such a design finds its match in an implementation case, whose goal is to show some paradigms and patterns which make easier to code distributed algorithms from a properly stated design.
